package linearfn

import munit.FunSuite
import scala.annotation.experimental
import TestPersonOps.*

/**
 * Tests for @ops annotation and auto-generated extension methods.
 *
 * TestPerson and Animal are now defined in src/main/scala and have their
 * extensions automatically generated by the sbt source generator.
 */
@experimental
class OpsAnnotationTest extends FunSuite:

  test("non-primitive argument automatically tracked - dependencies concatenated") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val combined = refs._1.singleRestrictedProductArg(refs._2)
      (combined, refs._1)
    )

    assertEquals(result, (TestPerson("Alice & Bob", 55), person1))
  }

  test("method with no arguments - dependencies preserved") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val greeting1 = refs._1.noArg()
      val greeting2 = refs._2.noArg()
      (greeting1, greeting2)
    )

    assertEquals(result, ("Hello, I'm Alice", "Hello, I'm Bob"))
  }

  test("primitive argument automatically tracked - dependencies concatenated") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val updated = refs._1.singleRestrictedPrimitiveArg("Alicia")
      (updated, refs._2)
    )

    assertEquals(result, (TestPerson("Alicia", 30), person2))
  }

  test("multiple primitive arguments automatically tracked - dependencies concatenated") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val greeting = refs._1.multipleRestrictedPrimitiveArgs("Hi", "there!")
      (greeting, refs._2)
    )

    assertEquals(result, ("Hi Alice there!", person2))
  }

  test("tracked non-primitive + primitive - dependencies concatenated for both args") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val intro = refs._1.restrictedProductArg_RestrictedPrimitiveArg(refs._2, "Hello")
      (intro, intro)
    )

    assertEquals(result, ("Hello, I'm Alice and this is Bob", "Hello, I'm Alice and this is Bob"))
  }

  test("primitive + tracked non-primitive - dependencies concatenated for both args") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val comparison = refs._1.restrictedPrimitiveArg_RestrictedProductArg("Team", refs._2)
      (comparison, comparison)
    )

    assertEquals(result, ("Team: Alice vs Bob", "Team: Alice vs Bob"))
  }

  test("method returning primitive from field access") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val upperName = refs._1.noArgFieldAccess()
      (upperName, refs._2)
    )

    assertEquals(result, ("ALICE", person2))
  }

  test("chaining method calls with tracked arguments") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)

    val result = RestrictedSelectable.LinearFn.apply((person1, person2))(refs =>
      val combined = refs._1.singleRestrictedProductArg(refs._2)
      val greeting = combined.noArg()
      (greeting, greeting)
    )

    assertEquals(result, ("Hello, I'm Alice & Bob", "Hello, I'm Alice & Bob"))
  }

  test("different non-primitive type automatically tracked - Animal argument") {
    val person = TestPerson("Alice", 30)
    val animal = Animal("cat", "meow")

    val result = RestrictedSelectable.LinearFn.apply((person, animal))(refs =>
      val greeting = refs._1.singleRestrictedDifferentProductArg(refs._2)
      (greeting, greeting)
    )

    assertEquals(result, ("Alice says hello to the cat", "Alice says hello to the cat"))
  }

  test("tracked Animal + primitive String - both automatically tracked") {
    val person = TestPerson("Alice", 30)
    val animal = Animal("dog", "woof")

    val result = RestrictedSelectable.LinearFn.apply((person, animal))(refs =>
      val intro = refs._1.restrictedDifferentProductArg_RestrictedPrimitiveArg(refs._2, "Hello")
      (intro, intro)
    )

    assertEquals(result, ("Hello, I'm Alice and this is a dog that says woof", "Hello, I'm Alice and this is a dog that says woof"))
  }

  test("multiple different non-primitive types all automatically tracked") {
    val person1 = TestPerson("Alice", 30)
    val person2 = TestPerson("Bob", 25)
    val animal = Animal("parrot", "squawk")

    val result = RestrictedSelectable.LinearFn.apply((person1, person2, animal))(refs =>
      val combined = refs._1.singleRestrictedProductArg(refs._2)
      val greeting = combined.singleRestrictedDifferentProductArg(refs._3)
      (greeting, greeting, greeting)
    )

    assertEquals(result, ("Alice & Bob says hello to the parrot", "Alice & Bob says hello to the parrot", "Alice & Bob says hello to the parrot"))
  }

  test("@unrestricted annotation opts out of tracking - second Animal not tracked") {
    val person = TestPerson("Alice", 30)
    val trackedAnimal = Animal("cat", "meow")

    val result = RestrictedSelectable.LinearFn.apply((person, trackedAnimal))(refs =>
      // Pass refs._2 TWICE: once as tracked (first param), once as @unrestricted (second param)
      // This would normally violate linearity, but @unrestricted makes the second usage not count
      // comparison only tracks dependency from first param (index 1) and receiver (index 0)
      val comparison = refs._1.restrictedProductArg_UnrestrictedProductArg(refs._2, refs._2)
      // We can return both comparison and refs._2 because:
      // - comparison depends on indices (1, 0)
      // - refs._2 depends on index (1)
      // Each input appears at most once per output, so it's linear
      (comparison, refs._2)
    )

    assertEquals(result, ("Alice compares cat (tracked) with cat (not tracked)", trackedAnimal))
  }
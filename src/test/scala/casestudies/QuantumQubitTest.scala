package test.casestudies

import munit.FunSuite
import linearfn.RestrictedSelectable
import linearfn.RestrictedSelectable.LinearFn
import test.TestUtils.*

/**
 * Case Study: Quantum Qubit Operations
 * Problem: Enforce linear usage of qubits to prevent cloning and ensure proper measurement.
 * Unlike file handles, not measuring a qbit is not a problem therefore we use apply not applyConsumed.
 */
class QuantumQubitTest extends FunSuite:
  import QuantumQubitOps.* // generated by @ops

  test("Bell pair then measure (linear, OK)") {
    val q1 = QuantumQubit.newQubit(init = false)
    val q2 = QuantumQubit.newQubit(init = false)

    // Build Bell pair: H on q1, then CNOT(q1â†’q2), then measure both
    val (m1, m2) =
      LinearFn.apply((q1, q2)) { refs =>
        val q1h = refs._1.hadamard()
        val entangled = q1h.cnot(refs._2)
        // Extract qubits from the tuple result
        val q1ent = entangled._1
        val q2ent = entangled._2
        (q1ent.measure(), q2ent.measure())
      }

    // Just verify we got booleans
    assert(m1 == true || m1 == false, "m1 should be a boolean")
    assert(m2 == true || m2 == false, "m2 should be a boolean")
  }

  test("Non-linear: attempt to duplicate the same qubit across results") {
    val obtained = compileErrors("""
      import QuantumQubitOps.*
      import linearfn.RestrictedSelectable

      val q1 = QuantumQubit.newQubit(false)
      val q2 = QuantumQubit.newQubit(false)

      // Same argument used twice in the returned tuple; other arg unused.
      RestrictedSelectable.LinearFn.apply((q1, q2)) { refs =>
        (refs._1.hadamard(), refs._1.x())
      }
    """)
    assert(
      obtained.contains(linearMsg),
      s"expected linear (argument-to-return) violation, obtained:\n$obtained"
    )
  }

  test("Non-affine: use the same qubit twice in a single operation (CNOT)") {
    val obtained = compileErrors("""
      import QuantumQubitOps.*
      import linearfn.RestrictedSelectable

      val q1 = QuantumQubit.newQubit(false)
      val q2 = QuantumQubit.newQubit(false)

      // Same handle used twice as control and target in one call.
      RestrictedSelectable.LinearFn.apply((q1, q2)) { refs =>
        val pair = refs._1.cnot(refs._1)
        (pair._1, refs._2)
      }
    """)
    assert(
      obtained.contains(affineMsg),
      s"expected affine (duplicate-use) violation, obtained:\n$obtained"
    )
  }

  test("Measure one qubit, operate on another (linear, OK)") {
    val q1 = QuantumQubit.newQubit(init = false)
    val q2 = QuantumQubit.newQubit(init = false)

    // Measure q1, apply operation to q2 - both used exactly once
    val (m1, q2Final) =
      LinearFn.apply((q1, q2)) { refs =>
        val m1 = refs._1.measure()
        val q2x = refs._2.x()
        (m1, q2x)
      }

    // Verify we got valid results
    assert(m1 == true || m1 == false, "m1 should be a boolean")
    assert(q2Final.id > 0, "q2Final should be a valid qubit")
  }

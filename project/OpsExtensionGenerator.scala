import sbt._
import scala.meta._
import scala.meta.dialects.Scala3

object OpsExtensionGenerator {

  def generate(sourceDir: File, targetDir: File, log: Logger): Seq[File] = {
    log.info("Generating extension methods for @ops annotated classes...")

    // Find all Scala source files
    val sourceFiles = (sourceDir ** "*.scala").get

    // Parse each file and look for @ops annotations
    val generatedFiles = sourceFiles.flatMap { file =>
      try {
        parseAndGenerate(file, targetDir, log)
      } catch {
        case e: Exception =>
          log.warn(s"Failed to parse ${file.getName}: ${e.getMessage}")
          None
      }
    }

    if (generatedFiles.nonEmpty) {
      log.info(s"Generated ${generatedFiles.size} extension method files")
    }

    generatedFiles
  }

  private def parseAndGenerate(sourceFile: File, targetDir: File, log: Logger): Option[File] = {
    val source = IO.read(sourceFile)
    val tree = source.parse[Source].get

    // Extract package name from source file
    val packageName = tree.stats.collectFirst {
      case Pkg(ref, _) => ref.toString
    }.getOrElse("linearfn") // Default to linearfn if no package declaration

    // Find classes annotated with @ops
    val opsClasses = tree.collect {
      case cls @ Defn.Class(mods, typeName, tparams, ctor, template)
        if mods.exists {
          case Mod.Annot(Init(Type.Name("ops"), _, _)) => true
          case _ => false
        } =>
        val methods = template.stats.collect {
          case defn: Defn.Def => defn
        }.filter { defn =>
          // Filter out special methods
          val excludedNames = Set(
            "hashCode", "equals", "toString", "canEqual",
            "productArity", "productPrefix", "productElement", "productElementName",
            "copy"
          )
          !excludedNames.contains(defn.name.value) &&
          !defn.name.value.startsWith("$") &&
          !defn.name.value.startsWith("_")
        }
        (typeName.value, tparams, methods)
    }

    if (opsClasses.isEmpty) {
      return None
    }

    // Generate extension methods for each @ops class
    opsClasses.headOption.map { case (className, typeParams, methods) =>

      val extensionCode = generateExtensionCode(packageName, className, typeParams, methods)

      // Write to target directory
      val targetFile = targetDir / s"${className}Extensions.scala"
      IO.createDirectory(targetDir)
      IO.write(targetFile, extensionCode)

      log.info(s"Generated extensions for $className -> ${targetFile.getName}")
      targetFile
    }
  }

  private def generateExtensionCode(packageName: String, className: String, typeParams: Seq[Type.Param], methods: Seq[Defn.Def]): String = {
    // Extract type parameter names for use in the extension
    val typeParamNames = typeParams.map(_.name.value)

    // Build type parameter list with bounds if any
    val typeParamDefs = typeParams.map { tp =>
      tp.tbounds match {
        case Type.Bounds(None, None) => tp.name.value
        case Type.Bounds(Some(lo), None) => s"${tp.name.value} >: ${lo.toString}"
        case Type.Bounds(None, Some(hi)) => s"${tp.name.value} <: ${hi.toString}"
        case Type.Bounds(Some(lo), Some(hi)) => s"${tp.name.value} >: ${lo.toString} <: ${hi.toString}"
      }
    }

    // Full class type with type parameters
    val fullClassName = if (typeParamNames.isEmpty) {
      className
    } else {
      s"$className[${typeParamNames.mkString(", ")}]"
    }

    // Generate extension methods individually (each in its own extension block)
    // This allows different receiver consumption state requirements per method
    val extensionMethods = methods.map { method =>
      generateMethodExtension(className, typeParamNames, typeParamDefs, fullClassName, method)
    }.mkString("\n\n  ")

    s"""package $packageName
       |
       |import linearfn.RestrictedSelectable
       |
       |// Generated extension methods for $className
       |// This file is auto-generated by OpsExtensionGenerator
       |
       |object ${className}Ops:
       |  $extensionMethods
       |""".stripMargin
  }

  private def generateMethodExtension(className: String, classTypeParams: Seq[String], typeParamDefs: Seq[String], fullClassName: String, method: Defn.Def): String = {
    val methodName = method.name.value

    // Get return type - handle both explicit and inferred types
    val returnType = method.decltpe match {
      case Some(tpe) => tpe.toString
      case None => method.body match {
        case Lit.String(_) => "String"
        case _ => "Any"
      }
    }

    // Check for @unrestricted annotations on parameters
    def hasUnrestrictedAnnot(param: Term.Param): Boolean = {
      param.mods.exists {
        case Mod.Annot(Init(Type.Name("unrestricted"), _, _)) => true
        case _ => false
      }
    }

    // Check for @consumed annotation on method
    val isConsumed = method.mods.exists {
      case Mod.Annot(Init(Type.Name("consumed"), _, _)) => true
      case _ => false
    }

    // Check for @unconsumed annotation on method
    val isUnconsumed = method.mods.exists {
      case Mod.Annot(Init(Type.Name("unconsumed"), _, _)) => true
      case _ => false
    }

    // Ensure @consumed and @unconsumed are mutually exclusive
    if (isConsumed && isUnconsumed) {
      throw new IllegalStateException(s"Method $methodName has both @consumed and @unconsumed annotations, which are mutually exclusive")
    }

    // Extract all term parameters from all parameter clauses
    val termParams = method.paramClauseGroups.flatMap { group =>
      group.paramClauses.flatMap {
        case clause: Term.ParamClause => clause.values
        case _ => Nil
      }
    }

    // Determine the receiver consumption state type
    // Default and @consumed: EmptyTuple (only unconsumed)
    // @unconsumed: C (any state)
    val receiverConsumptionType = if (isUnconsumed) "C" else "EmptyTuple"

    // Determine the return value consumption state type
    // Default: EmptyTuple
    // @consumed: Tuple1[true]
    // @unconsumed: C (preserves receiver state)
    val resultConsumptionType = if (isConsumed) {
      "Tuple1[true]"
    } else if (isUnconsumed) {
      "C"
    } else {
      "EmptyTuple"
    }

    // Build extension type parameters based on class type parameters
    val extensionTypeParams = if (typeParamDefs.isEmpty) {
      s"[D <: Tuple, C <: Tuple]"
    } else {
      s"[${typeParamDefs.mkString(", ")}, D <: Tuple, C <: Tuple]"
    }

    if (termParams.isEmpty) {
      // No parameters
      val methodDef = s"""def $methodName(): RestrictedSelectable.Restricted[$returnType, D, $resultConsumptionType] =
         |      p.stageCall[$returnType, D, $resultConsumptionType]("$methodName", EmptyTuple)""".stripMargin

      s"""extension $extensionTypeParams(p: RestrictedSelectable.Restricted[$fullClassName, D, $receiverConsumptionType])
         |    $methodDef""".stripMargin
    } else {
      // Generate type parameters for each parameter's dependencies and consumption states
      val typeParamsList = termParams.zipWithIndex.flatMap { case (_, i) =>
        Seq(s"D${i + 1} <: Tuple", s"C${i + 1} <: Tuple")
      }
      val typeParams = s"[${typeParamsList.mkString(", ")}]"

      // All parameters accept Restricted types (implicit conversion handles plain values)
      val paramList = termParams.zipWithIndex.map { case (p, i) =>
        val paramType = p.decltpe.get.toString
        s"${p.name.value}: RestrictedSelectable.Restricted[$paramType, D${i + 1}, C${i + 1}]"
      }.mkString(", ")

      // Build the result type by concatenating dependencies from non-@unrestricted parameters
      // The concatenation is right-nested: Tuple.Concat[D1, Tuple.Concat[D2, D]]
      val trackedParams = termParams.zipWithIndex.filterNot { case (p, _) => hasUnrestrictedAnnot(p) }

      val resultDepType = if (trackedParams.isEmpty) {
        // All parameters are @unrestricted, so result type is just D
        "D"
      } else {
        // Build right-nested Tuple.Concat for all tracked dependencies
        val depTypes = trackedParams.map { case (_, i) => s"D${i + 1}" }
        depTypes.foldRight("D")((dep, acc) => s"Tuple.Concat[$dep, $acc]")
      }

      // Build arguments tuple
      val argsTuple = if (termParams.size == 1) {
        s"Tuple1(${termParams.head.name.value})"
      } else {
        s"(${termParams.map(_.name.value).mkString(", ")})"
      }

      s"""extension $extensionTypeParams(p: RestrictedSelectable.Restricted[$fullClassName, D, $receiverConsumptionType])
         |    def $methodName$typeParams($paramList): RestrictedSelectable.Restricted[$returnType, $resultDepType, $resultConsumptionType] =
         |      p.stageCall[$returnType, $resultDepType, $resultConsumptionType]("$methodName", $argsTuple)""".stripMargin
    }
  }
}

import sbt._
import scala.meta._
import scala.meta.dialects.Scala3

object OpsExtensionGenerator {

  def generate(sourceDir: File, targetDir: File, log: Logger): Seq[File] = {
    log.info("Generating extension methods for @ops annotated classes...")

    // Find all Scala source files
    val sourceFiles = (sourceDir ** "*.scala").get

    // Parse each file and look for @ops annotations
    val generatedFiles = sourceFiles.flatMap { file =>
      try {
        parseAndGenerate(file, targetDir, log)
      } catch {
        case e: Exception =>
          log.warn(s"Failed to parse ${file.getName}: ${e.getMessage}")
          None
      }
    }

    if (generatedFiles.nonEmpty) {
      log.info(s"Generated ${generatedFiles.size} extension method files")
    }

    generatedFiles
  }

  private def parseAndGenerate(sourceFile: File, targetDir: File, log: Logger): Seq[File] = {
    val source = IO.read(sourceFile)
    val tree = source.parse[Source].get

    // Extract package name from source file
    val packageName = tree.stats.collectFirst {
      case Pkg(ref, _) => ref.toString
    }.getOrElse("linearfn") // Default to linearfn if no package declaration

    // Find classes annotated with @ops
    val opsClasses = tree.collect {
      case cls @ Defn.Class(mods, typeName, tparams, ctor, template)
        if mods.exists {
          case Mod.Annot(Init(Type.Name("ops"), _, _)) => true
          case _ => false
        } =>
        val methods = template.stats.collect {
          case defn: Defn.Def => defn
        }.filter { defn =>
          // Filter out special methods
          val excludedNames = Set(
            "hashCode", "equals", "toString", "canEqual",
            "productArity", "productPrefix", "productElement", "productElementName",
            "copy"
          )
          !excludedNames.contains(defn.name.value) &&
          !defn.name.value.startsWith("$") &&
          !defn.name.value.startsWith("_")
        }
        (typeName.value, tparams, methods)
    }

    if (opsClasses.isEmpty) {
      return Seq.empty
    }

    // Generate extension methods for ALL @ops classes in this file
    opsClasses.map { case (className, typeParams, methods) =>
      val extensionCode = generateExtensionCode(packageName, className, typeParams, methods)

      // Write to target directory
      val targetFile = targetDir / s"${className}Extensions.scala"
      IO.createDirectory(targetDir)
      IO.write(targetFile, extensionCode)

      log.info(s"Generated extensions for $className -> ${targetFile.getName}")
      targetFile
    }
  }

  private def generateExtensionCode(packageName: String, className: String, typeParams: Seq[Type.Param], methods: Seq[Defn.Def]): String = {
    // Extract type parameter names for use in the extension
    val typeParamNames = typeParams.map(_.name.value)

    // Build type parameter list with bounds if any
    val typeParamDefs = typeParams.map { tp =>
      tp.tbounds match {
        case Type.Bounds(None, None) => tp.name.value
        case Type.Bounds(Some(lo), None) => s"${tp.name.value} >: ${lo.toString}"
        case Type.Bounds(None, Some(hi)) => s"${tp.name.value} <: ${hi.toString}"
        case Type.Bounds(Some(lo), Some(hi)) => s"${tp.name.value} >: ${lo.toString} <: ${hi.toString}"
      }
    }

    // Full class type with type parameters
    val fullClassName = if (typeParamNames.isEmpty) {
      className
    } else {
      s"$className[${typeParamNames.mkString(", ")}]"
    }

    // Generate extension methods individually (each in its own extension block)
    // This allows different receiver consumption state requirements per method
    val extensionMethods = methods.map { method =>
      generateMethodExtension(className, typeParamNames, typeParamDefs, fullClassName, method)
    }.mkString("\n\n  ")

    s"""package $packageName
       |
       |import linearfn.RestrictedSelectable
       |
       |// Generated extension methods for $className
       |// This file is auto-generated by OpsExtensionGenerator
       |
       |object ${className}Ops:
       |  $extensionMethods
       |""".stripMargin
  }

  private def generateMethodExtension(className: String, classTypeParams: Seq[String], typeParamDefs: Seq[String], fullClassName: String, method: Defn.Def): String = {
    val methodName = method.name.value

    // Extract method-level type parameters
    val methodTypeParams = method.tparams.map { tp =>
      tp.tbounds match {
        case Type.Bounds(None, None) => tp.name.value
        case Type.Bounds(Some(lo), None) => s"${tp.name.value} >: ${lo.toString}"
        case Type.Bounds(None, Some(hi)) => s"${tp.name.value} <: ${hi.toString}"
        case Type.Bounds(Some(lo), Some(hi)) => s"${tp.name.value} >: ${lo.toString} <: ${hi.toString}"
      }
    }

    // Get return type - handle both explicit and inferred types
    val returnType = method.decltpe match {
      case Some(tpe) => tpe.toString
      case None => method.body match {
        case Lit.String(_) => "String"
        case _ => "Any"
      }
    }

    // Check for @unrestricted annotation on parameters
    def hasUnrestrictedAnnot(param: Term.Param): Boolean = {
      param.mods.exists {
        case Mod.Annot(Init(Type.Name("unrestricted"), _, _)) => true
        case _ => false
      }
    }

    // Check for @restrictedFn annotation on parameters
    def hasRestrictedFnAnnot(param: Term.Param): Boolean = {
      param.mods.exists {
        case Mod.Annot(Init(Type.Name("restrictedFn"), _, _)) => true
        case _ => false
      }
    }

    // Transform a function type to wrap its return type in Restricted
    // Only works for single-parameter functions (A => B)
    def transformFunctionReturnType(tpe: Type, index: Int): String = {
      tpe match {
        case Type.Function(params, res) if params.size == 1 =>
          // Single-parameter function - wrap return type
          val paramType = params.head.toString
          val returnType = res.toString
          s"$paramType => RestrictedSelectable.Restricted[$returnType, D${index + 1}, C${index + 1}]"
        case Type.Function(params, _) =>
          // Multi-parameter function - error
          throw new IllegalStateException(
            s"@restrictedFn can only be used on single-parameter functions (A => B), not on ${tpe.toString} " +
            s"which has ${params.size} parameters. " +
            s"Valid usage: def flatMap[B](@restrictedFn f: A => Query[B]): Query[B]"
          )
        case _ =>
          // Not a function - error
          throw new IllegalStateException(
            s"@restrictedFn can only be used on function parameters, not on ${tpe.toString}. " +
            s"Valid usage: def flatMap[B](@restrictedFn f: A => Query[B]): Query[B]"
          )
      }
    }

    // Check for @repeatable annotation on method
    val isRepeatable = method.mods.exists {
      case Mod.Annot(Init(Type.Name("repeatable"), _, _)) => true
      case _ => false
    }

    // Check for @consumed annotation on method
    val isConsumed = method.mods.exists {
      case Mod.Annot(Init(Type.Name("consumed"), _, _)) => true
      case _ => false
    }

    // Check for @unconsumed annotation on method
    val isUnconsumed = method.mods.exists {
      case Mod.Annot(Init(Type.Name("unconsumed"), _, _)) => true
      case _ => false
    }

    // Ensure annotations are mutually exclusive
    val annotationCount = Seq(isRepeatable, isConsumed, isUnconsumed).count(identity)
    if (annotationCount > 1) {
      throw new IllegalStateException(s"Method $methodName has multiple consumption annotations (@repeatable, @consumed, @unconsumed), which are mutually exclusive")
    }

    // Extract all term parameters from all parameter clauses
    val termParams = method.paramClauseGroups.flatMap { group =>
      group.paramClauses.flatMap {
        case clause: Term.ParamClause => clause.values
        case _ => Nil
      }
    }

    // Determine the receiver consumption state type
    // @unconsumed: C (any state)
    // @repeatable, @consumed, default: EmptyTuple (only unconsumed)
    val receiverConsumptionType = if (isUnconsumed) "C" else "EmptyTuple"

    // Determine the return value consumption state type
    // @repeatable: EmptyTuple (unconsumed → unconsumed)
    // @consumed or default: Tuple1[true] (unconsumed → consumed)
    // @unconsumed: C (preserves receiver state)
    val resultConsumptionType = if (isUnconsumed) {
      "C"
    } else if (isRepeatable) {
      "EmptyTuple"
    } else {
      // Default or @consumed: both consume
      "Tuple1[true]"
    }

    // Build extension type parameters based on class type parameters
    val extensionTypeParams = if (typeParamDefs.isEmpty) {
      s"[D <: Tuple, C <: Tuple]"
    } else {
      s"[${typeParamDefs.mkString(", ")}, D <: Tuple, C <: Tuple]"
    }

    if (termParams.isEmpty) {
      // No parameters - just include method type parameters
      val methodTypeParamsStr = if (methodTypeParams.isEmpty) "" else s"[${methodTypeParams.mkString(", ")}]"

      val methodDef = s"""def $methodName$methodTypeParamsStr(): RestrictedSelectable.Restricted[$returnType, D, $resultConsumptionType] =
         |      self.stageCall[$returnType, D, $resultConsumptionType]("$methodName", EmptyTuple)""".stripMargin

      s"""extension $extensionTypeParams(self: RestrictedSelectable.Restricted[$fullClassName, D, $receiverConsumptionType])
         |    $methodDef""".stripMargin
    } else {
      // Check each parameter for annotations
      val paramInfos = termParams.zipWithIndex.map { case (p, i) =>
        val isRestrictedFn = hasRestrictedFnAnnot(p)
        val isUnrestricted = hasUnrestrictedAnnot(p)
        (p, i, isRestrictedFn, isUnrestricted)
      }

      // Check if a type is a function type
      def isFunctionType(tpe: Type): Boolean = tpe match {
        case _: Type.Function => true
        case _ => false
      }

      // Generate type parameters based on parameter tracking needs
      val paramTypeParams = paramInfos.flatMap { case (p, i, isRestrictedFn, isUnrestricted) =>
        val paramType = p.decltpe.get
        if (isUnrestricted && !isRestrictedFn && isFunctionType(paramType)) {
          // @unrestricted function - uses implicit conversion, no type params
          Nil
        } else {
          // Everything else needs type params (tracked params, product types, @restrictedFn types)
          Seq(s"D${i + 1} <: Tuple", s"C${i + 1} <: Tuple")
        }
      }

      // Combine method type parameters with parameter type parameters
      val allTypeParams = methodTypeParams ++ paramTypeParams
      val typeParams = if (allTypeParams.isEmpty) "" else s"[${allTypeParams.mkString(", ")}]"

      // Build parameter list
      val paramList = paramInfos.map { case (p, i, isRestrictedFn, isUnrestricted) =>
        val paramName = p.name.value
        val paramType = p.decltpe.get

        if (isUnrestricted && !isRestrictedFn && isFunctionType(paramType)) {
          // @unrestricted function - use plain type, implicit conversion handles wrapping
          s"$paramName: ${paramType.toString}"
        } else if (isRestrictedFn) {
          // Has @restrictedFn annotation - transform the function return type
          s"$paramName: ${transformFunctionReturnType(paramType, i)}"
        } else {
          // Default tracked or @unrestricted product - wrap with Restricted
          s"$paramName: RestrictedSelectable.Restricted[${paramType.toString}, D${i + 1}, C${i + 1}]"
        }
      }.mkString(", ")

      // Build the result type by concatenating dependencies from tracked parameters
      val trackedParams = paramInfos.filterNot { case (_, _, _, isUnrestricted) => isUnrestricted }

      val resultDepType = if (trackedParams.isEmpty) {
        // All parameters are @unrestricted, so result type is just D
        "D"
      } else {
        // Build right-nested Tuple.Concat for all tracked dependencies
        val depTypes = trackedParams.map { case (_, i, _, _) => s"D${i + 1}" }
        depTypes.foldRight("D")((dep, acc) => s"Tuple.Concat[$dep, $acc]")
      }

      // Build arguments tuple
      val argsTuple = if (termParams.size == 1) {
        s"Tuple1(${termParams.head.name.value})"
      } else {
        s"(${termParams.map(_.name.value).mkString(", ")})"
      }

      s"""extension $extensionTypeParams(self: RestrictedSelectable.Restricted[$fullClassName, D, $receiverConsumptionType])
         |    def $methodName$typeParams($paramList): RestrictedSelectable.Restricted[$returnType, $resultDepType, $resultConsumptionType] =
         |      self.stageCall[$returnType, $resultDepType, $resultConsumptionType]("$methodName", $argsTuple)""".stripMargin
    }
  }
}

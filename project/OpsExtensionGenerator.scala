import sbt._
import scala.meta._
import scala.meta.dialects.Scala3

object OpsExtensionGenerator {

  def generate(sourceDir: File, targetDir: File, log: Logger): Seq[File] = {
    log.info("Generating extension methods for @ops annotated classes...")

    // Find all Scala source files
    val sourceFiles = (sourceDir ** "*.scala").get

    // Parse each file and look for @ops annotations
    val generatedFiles = sourceFiles.flatMap { file =>
      try {
        parseAndGenerate(file, targetDir, log)
      } catch {
        case e: Exception =>
          log.warn(s"Failed to parse ${file.getName}: ${e.getMessage}")
          None
      }
    }

    if (generatedFiles.nonEmpty) {
      log.info(s"Generated ${generatedFiles.size} extension method files")
    }

    generatedFiles
  }

  private def parseAndGenerate(sourceFile: File, targetDir: File, log: Logger): Option[File] = {
    val source = IO.read(sourceFile)
    val tree = source.parse[Source].get

    // Find classes annotated with @ops
    val opsClasses = tree.collect {
      case cls @ Defn.Class(mods, typeName, tparams, ctor, template)
        if mods.exists {
          case Mod.Annot(Init(Type.Name("ops"), _, _)) => true
          case _ => false
        } =>
        val methods = template.stats.collect {
          case defn: Defn.Def => defn
        }.filter { defn =>
          // Filter out special methods
          val excludedNames = Set(
            "hashCode", "equals", "toString", "canEqual",
            "productArity", "productPrefix", "productElement", "productElementName",
            "copy"
          )
          !excludedNames.contains(defn.name.value) &&
          !defn.name.value.startsWith("$") &&
          !defn.name.value.startsWith("_")
        }
        (typeName.value, methods)
    }

    if (opsClasses.isEmpty) {
      return None
    }

    // Generate extension methods for each @ops class
    opsClasses.headOption.map { case (className, methods) =>

      val extensionCode = generateExtensionCode(className, methods)

      // Write to target directory
      val targetFile = targetDir / s"${className}Extensions.scala"
      IO.createDirectory(targetDir)
      IO.write(targetFile, extensionCode)

      log.info(s"Generated extensions for $className -> ${targetFile.getName}")
      targetFile
    }
  }

  private def generateExtensionCode(className: String, methods: Seq[Defn.Def]): String = {
    val extensionMethods = methods.map { method =>
      generateMethodExtension(className, method)
    }.mkString("\n    ")

    s"""package linearfn
       |
       |// Generated extension methods for $className
       |// This file is auto-generated by OpsExtensionGenerator
       |
       |object ${className}Ops:
       |  extension [D <: Tuple](p: RestrictedSelectable.Restricted[$className, D])
       |    $extensionMethods
       |""".stripMargin
  }

  private def generateMethodExtension(className: String, method: Defn.Def): String = {
    val methodName = method.name.value

    // Get return type - handle both explicit and inferred types
    val returnType = method.decltpe match {
      case Some(tpe) => tpe.toString
      case None => method.body match {
        case Lit.String(_) => "String"
        case _ => "Any"
      }
    }

    // Check for @unrestricted annotations on parameters
    def hasUnrestrictedAnnot(param: Term.Param): Boolean = {
      param.mods.exists {
        case Mod.Annot(Init(Type.Name("unrestricted"), _, _)) => true
        case _ => false
      }
    }

    // Extract all term parameters from all parameter clauses
    val termParams = method.paramClauseGroups.flatMap { group =>
      group.paramClauses.flatMap {
        case clause: Term.ParamClause => clause.values
        case _ => Nil
      }
    }

    if (termParams.isEmpty) {
      // No parameters
      s"""def $methodName(): RestrictedSelectable.Restricted[$returnType, D] =
         |    p.stageCall[$returnType, D]("$methodName", EmptyTuple)""".stripMargin
    } else {
      // Generate type parameters for each parameter's dependencies
      val typeParamsList = termParams.zipWithIndex.map { case (_, i) =>
        s"D${i + 1} <: Tuple"
      }
      val typeParams = s"[${typeParamsList.mkString(", ")}]"

      // All parameters accept Restricted types (implicit conversion handles plain values)
      val paramList = termParams.zipWithIndex.map { case (p, i) =>
        val paramType = p.decltpe.get.toString
        s"${p.name.value}: RestrictedSelectable.Restricted[$paramType, D${i + 1}]"
      }.mkString(", ")

      // Build the result type by concatenating dependencies from non-@unrestricted parameters
      // The concatenation is right-nested: Tuple.Concat[D1, Tuple.Concat[D2, D]]
      val trackedParams = termParams.zipWithIndex.filterNot { case (p, _) => hasUnrestrictedAnnot(p) }

      val resultDepType = if (trackedParams.isEmpty) {
        // All parameters are @unrestricted, so result type is just D
        "D"
      } else {
        // Build right-nested Tuple.Concat for all tracked dependencies
        val depTypes = trackedParams.map { case (_, i) => s"D${i + 1}" }
        depTypes.foldRight("D")((dep, acc) => s"Tuple.Concat[$dep, $acc]")
      }

      // Build arguments tuple
      val argsTuple = if (termParams.size == 1) {
        s"Tuple1(${termParams.head.name.value})"
      } else {
        s"(${termParams.map(_.name.value).mkString(", ")})"
      }

      s"""def $methodName$typeParams($paramList): RestrictedSelectable.Restricted[$returnType, $resultDepType] =
         |    p.stageCall[$returnType, $resultDepType]("$methodName", $argsTuple)""".stripMargin
    }
  }
}
